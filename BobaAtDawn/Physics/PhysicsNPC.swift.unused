//
//  PhysicsNPC.swift
//  BobaAtDawn
//
//  Physics-enhanced NPC class that uses SpriteKit physics for smooth movement
//  while maintaining the existing NPC behavior and state machine
//

import SpriteKit

// MARK: - Physics-Enhanced NPC
class PhysicsNPC: SKLabelNode {
    
    // MARK: - Dependencies
    private let gridService: GridService
    private let npcService: NPCService
    private let movementController: NPCMovementController
    
    // MARK: - NPC Properties (unchanged from original)
    private(set) var state: NPCState = .entering
    private(set) var animalType: AnimalType
    private(set) var gridPosition: GridCoordinate
    
    // Timers
    private var stateTimer: TimeInterval = 0
    private var totalLifetime: TimeInterval = 0
    
    // Behavior
    private var currentTable: RotatableObject?
    private var carriedDrink: RotatableObject?
    private var targetCell: GridCoordinate?
    
    // Physics Integration
    private var lastPhysicsUpdate: TimeInterval = 0
    
    // MARK: - Initialization
    init(animal: AnimalType? = nil, 
         startPosition: GridCoordinate? = nil,
         gridService: GridService,
         npcService: NPCService) {
        
        // Store dependencies
        self.gridService = gridService
        self.npcService = npcService
        
        // Choose random animal if not specified
        self.animalType = animal ?? AnimalType.random()
        
        // Default start position (at front door)
        let doorPosition = GameConfig.World.doorGridPosition
        self.gridPosition = startPosition ?? doorPosition
        
        // Initialize visual representation
        super.init()
        
        // Set up visual properties
        text = animalType.rawValue
        fontSize = GameConfig.NPC.fontSize
        fontName = GameConfig.NPC.fontName
        horizontalAlignmentMode = .center
        verticalAlignmentMode = .center
        zPosition = GameConfig.NPC.zPosition
        
        // Set up physics body
        setupPhysicsBody()
        
        // Initialize movement controller
        self.movementController = NPCMovementController(
            physicsBody: self.physicsBody!,
            gridService: gridService,
            homePosition: gridPosition
        )
        
        // Position in world
        position = gridService.gridToWorld(gridPosition)
        
        // Reserve grid cell
        gridService.reserveCell(gridPosition)
        
        print("🦊 PhysicsNPC \(animalType.rawValue) spawned at grid \(gridPosition), world \(position)")
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    // MARK: - Physics Setup
    
    private func setupPhysicsBody() {
        physicsBody = PhysicsBodyFactory.createNPCBody()
        physicsBody?.node = self
        
        print("⚡ NPC \(animalType.rawValue) physics body created")
    }
    
    // MARK: - Update Loop (Physics-Enhanced)
    
    func update(deltaTime: TimeInterval) {
        // Update timers
        stateTimer += deltaTime
        totalLifetime += deltaTime
        
        // Update movement controller
        movementController.update(deltaTime: deltaTime)
        
        // Update grid position tracking
        updateGridPositionTracking()
        
        // State machine progression (unchanged logic)
        switch state {
        case .entering:
            updateEntering()
        case .wandering:
            updateWandering()
        case .sitting(let table):
            updateSitting(table: table)
        case .drinking(let timeStarted):
            updateDrinking(timeStarted: timeStarted)
        case .leaving(let satisfied):
            updateLeaving(satisfied: satisfied)
        }
        
        // Safety timeout
        if totalLifetime > GameConfig.NPC.maxLifetime {
            transitionToLeaving(satisfied: false)
        }
    }
    
    private func updateGridPositionTracking() {
        // Update grid position based on physics position
        let currentWorldPos = position
        let newGridPos = gridService.worldToGrid(currentWorldPos)
        
        if newGridPos != gridPosition && newGridPos.isValid() {
            // Free old cell and reserve new cell
            gridService.freeCell(gridPosition)
            
            if gridService.isCellAvailable(newGridPos) {
                gridService.reserveCell(newGridPos)
                gridPosition = newGridPos
                print("🦊 \(animalType.rawValue) moved to grid \(newGridPos)")
            } else {
                // Cell is occupied, keep old position reserved
                gridService.reserveCell(gridPosition)
            }
        }
    }
    
    // MARK: - State Updates (Physics-Enhanced)
    
    private func updateEntering() {
        let enteringDuration = Double.random(in: GameConfig.NPC.enteringDuration.min...GameConfig.NPC.enteringDuration.max)
        if stateTimer > enteringDuration {
            transitionToWandering()
        } else if !movementController.isMoving {
            moveToRandomNearbyCell()
        }
    }
    
    private func updateWandering() {
        let wanderingDuration = Double.random(in: GameConfig.NPC.wanderingDuration.min...GameConfig.NPC.wanderingDuration.max)
        if stateTimer > wanderingDuration {
            if findAndMoveToTable() {
                transitionToSitting()
            } else {
                stateTimer -= 10 // Retry soon
            }
        } else if !movementController.isMoving {
            // Occasionally wander to new location
            if Int(stateTimer * 2) % 8 == 0 && Int.random(in: 1...4) == 1 {
                moveToRandomNearbyCell()
            }
        }
    }
    
    private func updateSitting(table: RotatableObject?) {
        guard let table = table else {
            transitionToWandering()
            return
        }
        
        // Check for drink periodically
        if Int(stateTimer * 2) % 4 == 0 {
            if checkForDrinkOnTable(table: table) {
                transitionToDrinking()
                return
            }
        }
        
        // Timeout if sitting too long without service
        let sittingTimeout = Double.random(in: GameConfig.NPC.sittingTimeout.min...GameConfig.NPC.sittingTimeout.max)
        if stateTimer > sittingTimeout {
            transitionToLeaving(satisfied: false)
        }
    }
    
    private func updateDrinking(timeStarted: TimeInterval) {
        let enjoymentTime = Double.random(in: GameConfig.NPC.drinkEnjoymentTime.min...GameConfig.NPC.drinkEnjoymentTime.max)
        if stateTimer > timeStarted + enjoymentTime {
            transitionToLeaving(satisfied: true)
        }
    }
    
    private func updateLeaving(satisfied: Bool) {
        if Int(stateTimer * 10) % 15 == 0 {
            if npcService.isNearExit(gridPosition) {
                removeSelf()
            } else {
                moveTowardExit()
            }
        }
    }
    
    // MARK: - Physics Movement System
    
    private func moveToCell(_ targetCell: GridCoordinate) {
        guard targetCell.isValid() else { return }
        guard gridService.isCellAvailable(targetCell) else { return }
        guard !movementController.isMoving else { return }
        
        self.targetCell = targetCell
        
        // Use physics-based movement
        movementController.moveToGrid(targetCell) { [weak self] in
            self?.handleCellArrival(targetCell)
        }
        
        print("🦊 \(animalType.rawValue) moving to cell \(targetCell)")
    }
    
    private func handleCellArrival(_ cell: GridCoordinate) {
        self.targetCell = nil
        print("🦊 \(animalType.rawValue) arrived at cell \(cell)")
    }
    
    private func moveToRandomNearbyCell() {
        let radius = Int.random(in: 1...GameConfig.NPC.wanderRadius)
        let candidates = npcService.generateCandidateCells(from: gridPosition, radius: radius)
        
        if let randomCell = candidates.randomElement() {
            moveToCell(randomCell)
        } else {
            // Use physics-based wandering if no valid grid cells
            movementController.wanderRandomly()
        }
    }
    
    // MARK: - Table System (Physics-Enhanced)
    
    private func findAndMoveToTable() -> Bool {
        guard let scene = parent as? SKScene else { return false }
        
        let availableTables = npcService.findAvailableTables(in: scene)
        
        if availableTables.isEmpty {
            print("🦊 No tables found in scene")
            return false
        }
        
        if let chosenTable = availableTables.randomElement() {
            let tableGridPos = gridService.worldToGrid(chosenTable.position)
            let adjacentCells = gridService.getAvailableAdjacentCells(to: tableGridPos)
            
            if let sittingSpot = adjacentCells.randomElement() {
                currentTable = chosenTable
                moveToCell(sittingSpot)
                print("🦊 \(animalType.rawValue) moving to sit at table at \(tableGridPos)")
                return true
            }
        }
        
        print("🦊 \(animalType.rawValue) couldn't find available seating")
        return false
    }
    
    private func checkForDrinkOnTable(table: RotatableObject) -> Bool {
        let drinksOnTable = table.children.filter { $0.name == "drink_on_table" }
        
        if let drink = drinksOnTable.first {
            print("🦊 ✨ \(animalType.rawValue) found drink on table!")
            pickupDrinkFromTable(drink)
            return true
        }
        return false
    }
    
    private func pickupDrinkFromTable(_ drink: SKNode) {
        drink.removeFromParent()
        
        let carriedDrink = createCarriedDrink(from: drink)
        carriedDrink.position = GameConfig.NPC.CarriedDrink.carryOffset
        carriedDrink.zPosition = 1
        addChild(carriedDrink)
        
        let floatAction = SKAction.repeatForever(
            SKAction.sequence([
                SKAction.moveBy(x: 0, y: GameConfig.NPC.CarriedDrink.floatDistance, duration: GameConfig.NPC.CarriedDrink.floatDuration),
                SKAction.moveBy(x: 0, y: -GameConfig.NPC.CarriedDrink.floatDistance, duration: GameConfig.NPC.CarriedDrink.floatDuration)
            ])
        )
        carriedDrink.run(floatAction, withKey: "floating")
        
        self.carriedDrink = carriedDrink as? RotatableObject
        
        print("🦊 ✨ \(animalType.rawValue) picked up drink from table!")
    }
    
    private func createCarriedDrink(from tableDrink: SKNode) -> SKNode {
        let carriedVersion = SKSpriteNode(color: .brown, size: GameConfig.NPC.CarriedDrink.size)
        
        let lid = SKSpriteNode(color: .lightGray, size: GameConfig.NPC.CarriedDrink.lidSize)
        lid.position = GameConfig.NPC.CarriedDrink.lidOffset
        carriedVersion.addChild(lid)
        
        let straw = SKSpriteNode(color: .white, size: GameConfig.NPC.CarriedDrink.strawSize)
        straw.position = GameConfig.NPC.CarriedDrink.strawOffset
        carriedVersion.addChild(straw)
        
        return carriedVersion
    }
    
    // MARK: - Exit System (Physics-Enhanced)
    
    private func moveTowardExit() {
        if let targetCell = npcService.findPathToExit(from: gridPosition) {
            moveToCell(targetCell)
            print("🦊 \(animalType.rawValue) (\(state.displayName)) moving toward exit from \(gridPosition)")
        } else {
            // Use direct physics movement toward door if pathfinding fails
            let doorWorldPos = GameConfig.doorWorldPosition()
            movementController.currentTarget = doorWorldPos
            movementController.isMoving = true
            print("🦊 \(animalType.rawValue) using direct movement to exit")
        }
    }
    
    // MARK: - State Transitions (unchanged)
    
    private func transitionToWandering() {
        state = .wandering
        stateTimer = 0
        currentTable = nil
        print("🦊 \(animalType.rawValue) started wandering")
    }
    
    private func transitionToSitting() {
        state = .sitting(table: currentTable)
        stateTimer = 0
        print("🦊 \(animalType.rawValue) sat down at table and is browsing peacefully")
    }
    
    private func transitionToDrinking() {
        state = .drinking(timeStarted: stateTimer)
        print("🦊 \(animalType.rawValue) started drinking! Will enjoy for 5-10 seconds")
    }
    
    private func transitionToLeaving(satisfied: Bool) {
        state = .leaving(satisfied: satisfied)
        stateTimer = 0
        currentTable = nil
        
        if satisfied {
            startHappyAnimation()
            print("🦊 \(animalType.rawValue) leaving satisfied! ✨")
        } else {
            startNeutralAnimation()
            print("🦊 \(animalType.rawValue) leaving neutral")
        }
    }
    
    // Public method for external triggers (compatibility)
    func startLeaving(satisfied: Bool) {
        transitionToLeaving(satisfied: satisfied)
    }
    
    // MARK: - Animation System (unchanged)
    
    private func startHappyAnimation() {
        removeAction(forKey: "happy_shimmer")
        removeAction(forKey: "happy_shake")
        removeAction(forKey: "happy_scale")
        
        let shimmer = SKAction.repeatForever(
            SKAction.sequence([
                SKAction.scale(to: GameConfig.NPC.Animations.shimmerScaleAmount, duration: GameConfig.NPC.Animations.shimmerDuration),
                SKAction.scale(to: 1.0, duration: GameConfig.NPC.Animations.shimmerDuration)
            ])
        )
        run(shimmer, withKey: "happy_shimmer")
        
        let shake = SKAction.repeatForever(
            SKAction.sequence([
                SKAction.moveBy(x: -GameConfig.NPC.Animations.shakeDistance, y: 0, duration: GameConfig.NPC.Animations.shakeDuration),
                SKAction.moveBy(x: GameConfig.NPC.Animations.shakeDistance * 2, y: 0, duration: GameConfig.NPC.Animations.shakeDuration),
                SKAction.moveBy(x: -GameConfig.NPC.Animations.shakeDistance * 2, y: 0, duration: GameConfig.NPC.Animations.shakeDuration),
                SKAction.moveBy(x: GameConfig.NPC.Animations.shakeDistance, y: 0, duration: GameConfig.NPC.Animations.shakeDuration)
            ])
        )
        run(shake, withKey: "happy_shake")
        
        let colorFlash = SKAction.repeatForever(
            SKAction.sequence([
                SKAction.colorize(with: .yellow, colorBlendFactor: 0.3, duration: GameConfig.NPC.Animations.colorFlashDuration),
                SKAction.colorize(withColorBlendFactor: 0.0, duration: GameConfig.NPC.Animations.colorFlashDuration),
                SKAction.colorize(with: .white, colorBlendFactor: 0.2, duration: GameConfig.NPC.Animations.colorFlashDuration),
                SKAction.colorize(withColorBlendFactor: 0.0, duration: GameConfig.NPC.Animations.colorFlashDuration)
            ])
        )
        run(colorFlash, withKey: "happy_flash")
        
        print("✨ \(animalType.rawValue) is VERY HAPPY with shimmer + shake + flash effects!")
    }
    
    private func startNeutralAnimation() {
        removeAction(forKey: "neutral_sigh")
        
        let sigh = SKAction.repeatForever(
            SKAction.sequence([
                SKAction.scale(to: GameConfig.NPC.Animations.neutralScaleAmount, duration: GameConfig.NPC.Animations.neutralSighDuration),
                SKAction.scale(to: 1.0, duration: GameConfig.NPC.Animations.neutralSighDuration)
            ])
        )
        run(sigh, withKey: "neutral_sigh")
        
        let grayTint = SKAction.colorize(with: .gray, colorBlendFactor: GameConfig.NPC.Animations.neutralGrayBlend, duration: GameConfig.NPC.Animations.neutralFadeDuration)
        run(grayTint, withKey: "neutral_tint")
        
        print("😐 \(animalType.rawValue) is leaving disappointed (no drink)")
    }
    
    private func stopHappyAnimation() {
        removeAction(forKey: "happy_shimmer")
        removeAction(forKey: "happy_shake")
        removeAction(forKey: "happy_flash")
        
        let resetAction = SKAction.group([
            SKAction.scale(to: 1.0, duration: GameConfig.NPC.Animations.resetDuration),
            SKAction.move(to: position, duration: GameConfig.NPC.Animations.resetDuration),
            SKAction.colorize(withColorBlendFactor: 0.0, duration: GameConfig.NPC.Animations.resetDuration)
        ])
        run(resetAction)
    }
    
    private func stopNeutralAnimation() {
        removeAction(forKey: "neutral_sigh")
        removeAction(forKey: "neutral_tint")
        
        let resetAction = SKAction.group([
            SKAction.scale(to: 1.0, duration: GameConfig.NPC.Animations.resetDuration),
            SKAction.colorize(withColorBlendFactor: 0.0, duration: GameConfig.NPC.Animations.resetDuration)
        ])
        run(resetAction)
    }
    
    // MARK: - Lifecycle (Physics-Enhanced)
    
    private func removeSelf() {
        // Stop animations based on state
        switch state {
        case .leaving(let satisfied):
            if satisfied {
                stopHappyAnimation()
            } else {
                stopNeutralAnimation()
            }
        default:
            break
        }
        
        // Remove carried drink
        if let drink = carriedDrink {
            drink.removeFromParent()
        }
        
        // Free grid cell
        gridService.freeCell(gridPosition)
        
        // Stop physics movement
        movementController.stop()
        
        // Remove from scene
        removeFromParent()
        
        print("🦊 \(animalType.rawValue) left the shop")
    }
    
    // MARK: - Physics Interaction Methods
    
    func handlePhysicsContact(with other: SKNode) {
        // Handle physics-based collisions/contacts
        if other.name == "front_door" {
            print("🦊 \(animalType.rawValue) contacted door via physics")
            // Could trigger exit behavior here
        } else if other.physicsBody?.categoryBitMask == PhysicsCategory.character {
            print("🦊 \(animalType.rawValue) bumped into character")
            // Could trigger dialogue or reaction
        }
    }
    
    func applyPhysicsForce(_ force: CGVector) {
        physicsBody?.applyForce(force)
        print("🦊 Applied force to \(animalType.rawValue): \(force)")
    }
    
    func getCurrentPhysicsVelocity() -> CGVector {
        return physicsBody?.velocity ?? CGVector.zero
    }
    
    // MARK: - Debug (Enhanced)
    
    func getStateInfo() -> String {
        let physicsVel = getCurrentPhysicsVelocity()
        let speed = movementController.getCurrentSpeed()
        
        return """
        \(animalType.rawValue) - \(state.displayName) - \(Int(stateTimer))s
        Grid: \(gridPosition), World: (\(Int(position.x)), \(Int(position.y)))
        Physics: (\(String(format: "%.1f", physicsVel.dx)), \(String(format: "%.1f", physicsVel.dy))) Speed: \(String(format: "%.1f", speed))
        Moving: \(movementController.isMoving)
        """
    }
    
    func printDetailedDebugInfo() {
        print("🔍 NPC Debug Info:")
        print("🔍 " + getStateInfo().replacingOccurrences(of: "\n", with: "\n🔍 "))
        print("🔍 Movement Controller:")
        print("🔍 " + movementController.getDebugInfo().replacingOccurrences(of: "\n", with: "\n🔍 "))
    }
}

// MARK: - Backward Compatibility
extension PhysicsNPC {
    
    /// Compatibility for existing code that expects old NPC interface
    func getGridPosition() -> GridCoordinate {
        return gridPosition
    }
    
    func setGridPosition(_ position: GridCoordinate) {
        moveToCell(position)
    }
    
    /// Compatibility property
    var isMoving: Bool {
        return movementController.isMoving
    }
}
